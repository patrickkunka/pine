{"version":3,"sources":["../src/AstParser.js"],"names":["Models","Patterns","AstParser","parse","programString","classInstance","Program","tokens","ingestProgramString","parseTokensIntoAst","body","startIndex","token","matchToken","Whitespace","push","end","length","slice","match","RegExp","BOOLEAN","exec","Mappings","getLiteral","NUMBER","KEYWORD","getKeyword","PUNCTUATOR","getPunctuator","STRING","IDENTIFIER","getIdentifier","WHITESPACE","getWhitespace","Error","i","type","parsingOrder","Model","Util","pascalCase","mapper","pattern","traverseTokens","testTokensAgainstPattern","tokensString","join","re","getStartIndexFromMatch","structure","class","toString","matchIndex","index","stringBefore","split","module","exports"],"mappings":"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","file":"AstParser.js","sourcesContent":["import * as Models   from './models';\nimport * as Patterns from './Patterns';\nimport Util          from './Util';\nimport Mappings      from './Mappings';\nimport parsingOrder  from './parsingOrder.json';\n\nclass AstParser {\n    /**\n     * @param   {string} programString\n     * @param   {object} [classInstance=null]\n     * @return  {Program}\n     */\n\n    static parse(programString, classInstance=null) {\n        const Program = new Models.Program();\n        const tokens = AstParser.ingestProgramString(programString);\n\n        AstParser.parseTokensIntoAst(tokens, classInstance);\n\n        Program.body = tokens;\n\n        return Program;\n    }\n\n    /**\n     * @param   {string} programString\n     * @return  {Array.<Token>}\n     */\n\n    static ingestProgramString(programString) {\n        const tokens = [];\n\n        let startIndex = 0;\n        let token = null;\n\n        while ((token = AstParser.matchToken(programString, startIndex))) {\n            if (!(token instanceof Models.Whitespace)) {\n                tokens.push(token);\n            }\n\n            startIndex = token.end;\n\n            if (startIndex > programString.length - 1) {\n                // End of string\n\n                break;\n            }\n        }\n\n        return tokens;\n    }\n\n    /**\n     * @param   {string} programString\n     * @param   {number} startIndex\n     * @return  {Token|null}\n     */\n\n    static matchToken(programString, startIndex) {\n        const slice = programString.slice(startIndex);\n\n        let match = null;\n\n        if ((match = new RegExp(Patterns.BOOLEAN).exec(slice))) {\n            return Mappings.getLiteral(match, startIndex, 'boolean');\n        } if ((match = new RegExp(Patterns.NUMBER).exec(slice))) {\n            return Mappings.getLiteral(match, startIndex, 'number');\n        } else if ((match = new RegExp(Patterns.KEYWORD).exec(slice))) {\n            return Mappings.getKeyword(match, startIndex);\n        } else if ((match = new RegExp(Patterns.PUNCTUATOR).exec(slice))) {\n            return Mappings.getPunctuator(match, startIndex);\n        } else if ((match = new RegExp(Patterns.STRING).exec(slice))) {\n            return Mappings.getLiteral(match, startIndex, 'string');\n        } else if ((match = new RegExp(Patterns.IDENTIFIER).exec(slice))) {\n            return Mappings.getIdentifier(match, startIndex);\n        } else if ((match = new RegExp(Patterns.WHITESPACE).exec(slice))) {\n            return Mappings.getWhitespace(match, startIndex);\n        }\n\n        throw new Error('[ast-parser] Unknown token');\n    }\n\n    /**\n     * @param   {Array.<Token>}   tokens\n     * @param   {Models.Class}    classInstance\n     * @return  {void}\n     */\n\n    static parseTokensIntoAst(tokens, classInstance) {\n        for (let i = 0, type; i < parsingOrder.length; i++) {\n            type = parsingOrder[i];\n\n            let Model = Models[Util.pascalCase(type)];\n            let mapper = Mappings['map' + Util.pascalCase(type)];\n            let pattern = Patterns[type];\n\n            AstParser.traverseTokens(tokens, Model, mapper, pattern, classInstance);\n        }\n    }\n\n    /**\n     * @static\n     * @param   {Array.<Token>}   tokens\n     * @param   {string}          pattern\n     * @return  {number}\n     */\n\n    static testTokensAgainstPattern(tokens, pattern) {\n        const tokensString = tokens.join(' ');\n        const re = new RegExp(pattern, 'g');\n        const match = re.exec(tokensString);\n\n        const startIndex = match ? AstParser.getStartIndexFromMatch(match, tokensString) : -1;\n\n        return startIndex;\n    }\n\n    /**\n     * @static\n     * @param {Array.<Token>}       tokens\n     * @param {function}            Model\n     * @param {function}            Mapper\n     * @param {string}              pattern\n     * @param {Models.Class|null}   classInstance\n     */\n\n    static traverseTokens(tokens, Model, mapper, pattern, classInstance) {\n        let startIndex = -1;\n\n        while ((startIndex = AstParser.testTokensAgainstPattern(tokens, pattern)) > -1) {\n            let structure = new Model();\n\n            structure.class = classInstance;\n\n            mapper(structure, tokens, startIndex);\n\n            if (structure.toString() === 'block_statement') {\n                AstParser.parseTokensIntoAst(structure.body, classInstance);\n            }\n        }\n    }\n\n    /**\n     * @static\n     * @param   {object} match\n     * @param   {string} tokensString\n     * @return  {number}\n     */\n\n    static getStartIndexFromMatch(match, tokensString) {\n        const matchIndex = match.index;\n        const stringBefore = tokensString.slice(0, matchIndex);\n        const startIndex = stringBefore.split(' ').length;\n\n        return startIndex - 1;\n    }\n}\n\nAstParser.Models = Models;\nAstParser.Patterns = Patterns;\n\nmodule.exports = AstParser;"]}