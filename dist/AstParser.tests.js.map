{"version":3,"sources":["../src/AstParser.tests.js"],"names":["describe","it","code","program","AstParser","parse","token","body","assert","instanceOf","Models","Literal","equal","kind","content","raw","MemberExpression","object","Identifier","property","Keyword","UnaryExpression","argument","operator","AssignmentExpression","left","right","BinaryExpression","LogicalExpression","length","CallExpression","callee","arguments","VariableDeclaration","identifier","init","ReturnStatement","logicalExpression","blockBody","BlockStatement","functionBody","FunctionDeclaration","params","consequent","IfStatement","test","alternate","altenative"],"mappings":"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","file":"AstParser.tests.js","sourcesContent":["import {assert} from 'chai';\n\nimport AstParser, {Models} from './AstParser';\n\ndescribe('AstParser', function() {\n    it('should recognise a string literal', () => {\n        const code = '\"foo\"';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'string');\n        assert.equal(token.content, 'foo');\n        assert.equal(token.raw, '\"foo\"');\n    });\n\n    it('should recognise an empty string literal', () => {\n        const code = '\"\"';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'string');\n        assert.equal(token.content, '');\n        assert.equal(token.raw, '\"\"');\n    });\n\n    it('should recognise a number literal', () => {\n        const code = '0';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'number');\n        assert.equal(token.content, '0');\n    });\n\n    it('should recognise a `true` boolean literal', () => {\n        const code = 'true';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'boolean');\n        assert.equal(token.content, 'true');\n    });\n\n    it('should recognise a `false` boolean literal', () => {\n        const code = 'false';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'boolean');\n        assert.equal(token.content, 'false');\n    });\n\n    it('should recognise a member expression', () => {\n        const code = 'foo.bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.MemberExpression);\n\n        assert.instanceOf(token.object, Models.Identifier);\n        assert.equal(token.object.content, 'foo');\n\n        assert.instanceOf(token.property, Models.Identifier);\n        assert.equal(token.property.content, 'bar');\n    });\n\n    it('should recognise a member expression using `this`', () => {\n        const code = 'this.bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.MemberExpression);\n\n        assert.instanceOf(token.object, Models.Keyword);\n        assert.equal(token.object.content, 'this');\n\n        assert.instanceOf(token.property, Models.Identifier);\n        assert.equal(token.property.content, 'bar');\n    });\n\n    it('should recognise a nested member expression', () => {\n        const code = 'this.foo.bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.MemberExpression);\n\n        assert.instanceOf(token.object, Models.Keyword);\n        assert.equal(token.object.content, 'this');\n\n        assert.instanceOf(token.property, Models.MemberExpression);\n\n        assert.instanceOf(token.property.object, Models.Identifier);\n        assert.equal(token.property.object.content, 'foo');\n\n        assert.instanceOf(token.property.property, Models.Identifier);\n        assert.equal(token.property.property.content, 'bar');\n    });\n\n    it('should recognise a unary expression with an identifier as its argument', () => {\n        const code = '!foo';\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.UnaryExpression);\n        assert.instanceOf(token.argument, Models.Identifier);\n\n        assert.equal(token.operator.content, '!');\n    });\n\n    it('should recognise a unary expression with a member expression as its argument', () => {\n        const code = '!this.isFoo';\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.UnaryExpression);\n        assert.instanceOf(token.argument, Models.MemberExpression);\n\n        assert.equal(token.operator.content, '!');\n    });\n\n    it('should recognise assignment of identifier to identifier', () => {\n        const code = 'foo = bar;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.AssignmentExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '=');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise assignment of a literal to an identifier', () => {\n        const code = 'foo = 2;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.AssignmentExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '=');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.kind, 'number');\n        assert.equal(token.right.content, '2');\n    });\n\n    it('should recognise assignment of a keyword to a member exression', () => {\n        const code = 'this.foo.bar = this;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.AssignmentExpression);\n        assert.instanceOf(token.left, Models.MemberExpression);\n\n        assert.equal(token.operator.content, '=');\n\n        assert.instanceOf(token.right, Models.Keyword);\n        assert.equal(token.right.content, 'this');\n    });\n\n    it('should recognise a binary expression', () => {\n        const code = 'foo > 2';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '>');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.content, '2');\n    });\n\n    it('should recognise a binary expression', () => {\n        const code = 'foo > 2';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '>');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.content, '2');\n    });\n\n    it('should recognise a binary expression with a double compound operator', () => {\n        const code = 'this <= 10';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Keyword);\n\n        assert.equal(token.operator.content, '<=');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.content, '10');\n    });\n\n    it('should recognise a binary expression with containing a unary expression', () => {\n        const code = 'this > -1';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Keyword);\n\n        assert.equal(token.operator.content, '>');\n\n        assert.instanceOf(token.right, Models.UnaryExpression);\n        assert.equal(token.right.argument.content, '1');\n        assert.equal(token.right.operator.content, '-');\n    });\n\n    it('should recognise a binary expression with a triple compound operator', () => {\n        const code = 'foo !== bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '!==');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a binary expression containing a null pointer', () => {\n        const code = 'foo !== null';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '!==');\n\n        assert.instanceOf(token.right, Models.Keyword);\n        assert.equal(token.right.content, 'null');\n    });\n\n    it('should recognise a binary expression wrapped in parentheses', () => {\n        const code = '(foo === bar)';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '===');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a logical expression', () => {\n        const code = 'foo && bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a logical expression wrapped in parentheses', () => {\n        const code = '(foo && bar)';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a logical expression containing a unary expression', () => {\n        const code = 'foo && !bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.UnaryExpression);\n        assert.equal(token.right.argument.content, 'bar');\n        assert.equal(token.right.operator.content, '!');\n    });\n\n    it('should recognise a logical expression containing a binary expression', () => {\n        const code = 'foo && bar > 4';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.BinaryExpression);\n\n        assert.instanceOf(token.right.left, Models.Identifier);\n        assert.equal(token.right.left.content, 'bar');\n\n        assert.equal(token.right.operator.content, '>');\n\n        assert.instanceOf(token.right.right, Models.Literal);\n        assert.equal(token.right.right.content, '4');\n    });\n\n    it('should recognise a logical expression containing two binary expressions', () => {\n        const code = '(this.bar !== null && this.bar !== \"\")';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.equal(program.body.length, 1);\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.BinaryExpression);\n\n        assert.instanceOf(token.left.left, Models.MemberExpression);\n        assert.equal(token.left.left.property.content, 'bar');\n\n        assert.equal(token.left.operator.content, '!==');\n\n        assert.instanceOf(token.left.right, Models.Keyword);\n        assert.equal(token.left.right.content, 'null');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.BinaryExpression);\n\n        assert.instanceOf(token.right.left, Models.MemberExpression);\n        assert.instanceOf(token.right.left.object, Models.Keyword);\n\n        assert.equal(token.right.operator.content, '!==');\n\n        assert.instanceOf(token.right.right, Models.Literal);\n        assert.equal(token.right.right.content, '');\n    });\n\n    it('should parse compound logical expressions from left to right', () => {\n        const code = 'foo && bar || baz';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n        assert.instanceOf(token.left, Models.LogicalExpression);\n\n        assert.equal(token.operator.content, '||');\n\n        assert.instanceOf(token.right, Models.Identifier);\n    });\n\n    it('should parse compound logical expressions according to parentheses placement', () => {\n        const code = 'foo && (bar || baz)';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.LogicalExpression);\n    });\n\n    it('should recognise a call expression upon an identifier', () => {\n        const code = 'foo();';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.CallExpression);\n        assert.instanceOf(token.callee, Models.Identifier);\n\n        assert.equal(token.callee.content, 'foo');\n        assert.equal(token.arguments.length, 0);\n    });\n\n    it('should recognise a call expression with an arbitrary number of arguments', () => {\n        const code = 'foo(foo, 2, false);';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.CallExpression);\n        assert.instanceOf(token.callee, Models.Identifier);\n\n        assert.equal(token.callee.content, 'foo');\n        assert.equal(token.arguments.length, 3);\n\n        assert.instanceOf(token.arguments[0], Models.Identifier);\n        assert.instanceOf(token.arguments[1], Models.Literal);\n        assert.instanceOf(token.arguments[2], Models.Literal);\n    });\n\n    it('should recognise a call expression upon a member expression', () => {\n        const code = 'console.log(\"foo\");';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.CallExpression);\n        assert.instanceOf(token.callee, Models.MemberExpression);\n        assert.instanceOf(token.callee.object, Models.Identifier);\n\n        assert.equal(token.callee.object.content, 'console');\n\n        assert.instanceOf(token.callee.property, Models.Identifier);\n\n        assert.equal(token.callee.property.content, 'log');\n        assert.equal(token.arguments.length, 1);\n\n        assert.instanceOf(token.arguments[0], Models.Literal);\n    });\n\n    it('should recognise a variable declaration with keyword `var`', () => {\n        const code = 'var foo = \"bar\";';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.VariableDeclaration);\n\n        assert.equal(token.kind, 'var');\n\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.identifier.content, 'foo');\n\n        assert.instanceOf(token.init, Models.Literal);\n\n        assert.equal(token.init.content, 'bar');\n    });\n\n    it('should recognise a variable declaration with keyword `const`', () => {\n        const code = 'const foo = false;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.VariableDeclaration);\n\n        assert.equal(token.kind, 'const');\n\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.identifier.content, 'foo');\n\n        assert.instanceOf(token.init, Models.Literal);\n\n        assert.equal(token.init.content, 'false');\n    });\n\n    it('should recognise a variable declaration with keyword `let`', () => {\n        const code = 'let foo = 10;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.VariableDeclaration);\n\n        assert.equal(token.kind, 'let');\n\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.identifier.content, 'foo');\n\n        assert.instanceOf(token.init, Models.Literal);\n\n        assert.equal(token.init.content, '10');\n    });\n\n    it('should recognise a return statement with no argument', () => {\n        const code = 'return;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n\n        assert.equal(token.argument, null);\n    });\n\n    it('should recognise a return statement with an identifier as an argument', () => {\n        const code = 'return foo;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n\n        assert.instanceOf(token.argument, Models.Identifier);\n\n        assert.equal(token.argument.content, 'foo');\n    });\n\n    it('should recognise a return statement with a logical expression as an argument', () => {\n        const code = 'return foo && bar;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(token.argument, Models.LogicalExpression);\n    });\n\n    it('should recognise a return statement with a binary expression as an argument', () => {\n        const code = 'return foo > 3;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(token.argument, Models.BinaryExpression);\n    });\n\n    it('should recognise a return statement with a compound logical expression as an argument', () => {\n        const code = 'return this.foo === \"bar\" && this.isFoo && this.isBar;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const logicalExpression = token.argument;\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(logicalExpression, Models.LogicalExpression);\n\n        assert.instanceOf(logicalExpression.left, Models.LogicalExpression);\n        assert.instanceOf(logicalExpression.left.left, Models.BinaryExpression);\n        assert.instanceOf(logicalExpression.left.right, Models.MemberExpression);\n        assert.instanceOf(logicalExpression.right, Models.MemberExpression);\n    });\n\n    it('should recognise a return statement with a unary expression as an argument', () => {\n        const code = 'return !this.isFoo;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(token.argument, Models.UnaryExpression);\n\n        assert.equal(token.argument.operator.content, '!');\n    });\n\n    it('should recognise an abstract block statement', () => {\n        const code = (\n            `{\n                var foo = 'bar';\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const blockBody = program.body[0].body;\n\n        assert.instanceOf(token, Models.BlockStatement);\n        assert.instanceOf(blockBody[0], Models.VariableDeclaration);\n    });\n\n    it('should recognise an abstract block statement with multiple statements', () => {\n        const code = (\n            `{\n                var foo = 'bar';\n\n                return foo || false;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const blockBody = program.body[0].body;\n\n        assert.instanceOf(token, Models.BlockStatement);\n        assert.instanceOf(blockBody[0], Models.VariableDeclaration);\n        assert.instanceOf(blockBody[1], Models.ReturnStatement);\n    });\n\n    it('should recognise a function declaration', () => {\n        const code = (\n            `function foo() {\n                var bar = 'foo';\n\n                return bar;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const functionBody = token.body.body;\n\n        assert.instanceOf(token, Models.FunctionDeclaration);\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.params.length, 0);\n\n        assert.instanceOf(functionBody[0], Models.VariableDeclaration);\n        assert.instanceOf(functionBody[1], Models.ReturnStatement);\n    });\n\n    it('should recognise a function declaration with one or more paramters', () => {\n        const code = (\n            `function foo(x, y) {\n                return x > y;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const functionBody = token.body.body;\n\n        assert.instanceOf(token, Models.FunctionDeclaration);\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.params.length, 2);\n        assert.equal(token.params[0].content, 'x');\n        assert.equal(token.params[1].content, 'y');\n\n        assert.instanceOf(functionBody[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with only a consequent', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a single identifier as a test', () => {\n        const code = (\n            `if (isFoo) {\n                return true;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.Identifier);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a single member expression as a test', () => {\n        const code = (\n            `if (this.isFoo) {\n                return true;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.MemberExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a consequent and alternate', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            } else {\n                return false;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n        const alternate = token.alternate;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a nested if statement within the alternate', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            } else if (x < y) {\n                return false;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n        const alternate = token.alternate;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate, Models.IfStatement);\n\n        assert.instanceOf(alternate.consequent.body[0], Models.ReturnStatement);\n        assert.equal(alternate.altenative, null);\n    });\n\n    it('should recognise an if statement with a full nested if statement within the alternate', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            } else if (x < y) {\n                return false;\n            } else {\n                return;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n        const alternate = token.alternate;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate, Models.IfStatement);\n\n        assert.instanceOf(alternate.consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate.alternate.body[0], Models.ReturnStatement);\n    });\n});"]}