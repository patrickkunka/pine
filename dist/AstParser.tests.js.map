{"version":3,"sources":["../src/AstParser.tests.js"],"names":["describe","it","code","program","parse","token","body","instanceOf","Literal","equal","kind","content","raw","MemberExpression","object","Identifier","property","Keyword","UnaryExpression","argument","operator","AssignmentExpression","left","right","BinaryExpression","LogicalExpression","length","CallExpression","callee","arguments","VariableDeclaration","identifier","init","ReturnStatement","logicalExpression","blockBody","BlockStatement","functionBody","FunctionDeclaration","params","consequent","IfStatement","test","alternate","altenative"],"mappings":"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","file":"AstParser.tests.js","sourcesContent":["import {assert} from 'chai';\n\nimport AstParser, {Models} from './AstParser';\n\ndescribe('AstParser', function() {\n    it('should recognise a string literal', () => {\n        const code = '\"foo\"';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'string');\n        assert.equal(token.content, 'foo');\n        assert.equal(token.raw, '\"foo\"');\n    });\n\n    it('should recognise an empty string literal', () => {\n        const code = '\"\"';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'string');\n        assert.equal(token.content, '');\n        assert.equal(token.raw, '\"\"');\n    });\n\n    it('should recognise a number literal', () => {\n        const code = '0';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'number');\n        assert.equal(token.content, '0');\n    });\n\n    it('should recognise a `true` boolean literal', () => {\n        const code = 'true';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'boolean');\n        assert.equal(token.content, 'true');\n    });\n\n    it('should recognise a `false` boolean literal', () => {\n        const code = 'false';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.Literal);\n        assert.equal(token.kind, 'boolean');\n        assert.equal(token.content, 'false');\n    });\n\n    it('should recognise a member expression', () => {\n        const code = 'foo.bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.MemberExpression);\n\n        assert.instanceOf(token.object, Models.Identifier);\n        assert.equal(token.object.content, 'foo');\n\n        assert.instanceOf(token.property, Models.Identifier);\n        assert.equal(token.property.content, 'bar');\n    });\n\n    it('should recognise a member expression using `this`', () => {\n        const code = 'this.bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.MemberExpression);\n\n        assert.instanceOf(token.object, Models.Keyword);\n        assert.equal(token.object.content, 'this');\n\n        assert.instanceOf(token.property, Models.Identifier);\n        assert.equal(token.property.content, 'bar');\n    });\n\n    it('should recognise a nested member expression', () => {\n        const code = 'this.foo.bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.MemberExpression);\n\n        assert.instanceOf(token.object, Models.Keyword);\n        assert.equal(token.object.content, 'this');\n\n        assert.instanceOf(token.property, Models.MemberExpression);\n\n        assert.instanceOf(token.property.object, Models.Identifier);\n        assert.equal(token.property.object.content, 'foo');\n\n        assert.instanceOf(token.property.property, Models.Identifier);\n        assert.equal(token.property.property.content, 'bar');\n    });\n\n    it('should recognise a unary expression with an identifier as its argument', () => {\n        const code = '!foo';\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.UnaryExpression);\n        assert.instanceOf(token.argument, Models.Identifier);\n\n        assert.equal(token.operator.content, '!');\n    });\n\n    it('should recognise a unary expression with a member expression as its argument', () => {\n        const code = '!this.isFoo';\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.UnaryExpression);\n        assert.instanceOf(token.argument, Models.MemberExpression);\n\n        assert.equal(token.operator.content, '!');\n    });\n\n    it('should recognise assignment of identifier to identifier', () => {\n        const code = 'foo = bar;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.AssignmentExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '=');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise assignment of a literal to an identifier', () => {\n        const code = 'foo = 2;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.AssignmentExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '=');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.kind, 'number');\n        assert.equal(token.right.content, '2');\n    });\n\n    it('should recognise assignment of a keyword to a member exression', () => {\n        const code = 'this.foo.bar = this;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.AssignmentExpression);\n        assert.instanceOf(token.left, Models.MemberExpression);\n\n        assert.equal(token.operator.content, '=');\n\n        assert.instanceOf(token.right, Models.Keyword);\n        assert.equal(token.right.content, 'this');\n    });\n\n    it('should recognise a binary expression', () => {\n        const code = 'foo > 2';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '>');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.content, '2');\n    });\n\n    it('should recognise a binary expression', () => {\n        const code = 'foo > 2';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '>');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.content, '2');\n    });\n\n    it('should recognise a binary expression with a double compound operator', () => {\n        const code = 'this <= 10';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Keyword);\n\n        assert.equal(token.operator.content, '<=');\n\n        assert.instanceOf(token.right, Models.Literal);\n        assert.equal(token.right.content, '10');\n    });\n\n    it('should recognise a binary expression with containing a unary expression', () => {\n        const code = 'this > -1';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Keyword);\n\n        assert.equal(token.operator.content, '>');\n\n        assert.instanceOf(token.right, Models.UnaryExpression);\n        assert.equal(token.right.argument.content, '1');\n        assert.equal(token.right.operator.content, '-');\n    });\n\n    it('should recognise a binary expression with a triple compound operator', () => {\n        const code = 'foo !== bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '!==');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a binary expression containing a null pointer', () => {\n        const code = 'foo !== null';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '!==');\n\n        assert.instanceOf(token.right, Models.Keyword);\n        assert.equal(token.right.content, 'null');\n    });\n\n    it('should recognise a binary expression wrapped in parentheses', () => {\n        const code = '(foo === bar)';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.BinaryExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '===');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a logical expression', () => {\n        const code = 'foo && bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a logical expression wrapped in parentheses', () => {\n        const code = '(foo && bar)';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.Identifier);\n        assert.equal(token.right.content, 'bar');\n    });\n\n    it('should recognise a logical expression containing a unary expression', () => {\n        const code = 'foo && !bar';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.UnaryExpression);\n        assert.equal(token.right.argument.content, 'bar');\n        assert.equal(token.right.operator.content, '!');\n    });\n\n    it('should recognise a logical expression containing a binary expression', () => {\n        const code = 'foo && bar > 4';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.Identifier);\n        assert.equal(token.left.content, 'foo');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.BinaryExpression);\n\n        assert.instanceOf(token.right.left, Models.Identifier);\n        assert.equal(token.right.left.content, 'bar');\n\n        assert.equal(token.right.operator.content, '>');\n\n        assert.instanceOf(token.right.right, Models.Literal);\n        assert.equal(token.right.right.content, '4');\n    });\n\n    it('should recognise a logical expression containing two binary expressions', () => {\n        const code = '(this.bar !== null && this.bar !== \"\")';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.equal(program.body.length, 1);\n        assert.instanceOf(token, Models.LogicalExpression);\n\n        assert.instanceOf(token.left, Models.BinaryExpression);\n\n        assert.instanceOf(token.left.left, Models.MemberExpression);\n        assert.equal(token.left.left.property.content, 'bar');\n\n        assert.equal(token.left.operator.content, '!==');\n\n        assert.instanceOf(token.left.right, Models.Keyword);\n        assert.equal(token.left.right.content, 'null');\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.BinaryExpression);\n\n        assert.instanceOf(token.right.left, Models.MemberExpression);\n        assert.instanceOf(token.right.left.object, Models.Keyword);\n\n        assert.equal(token.right.operator.content, '!==');\n\n        assert.instanceOf(token.right.right, Models.Literal);\n        assert.equal(token.right.right.content, '');\n    });\n\n    it('should parse compound logical expressions from left to right', () => {\n        const code = 'foo && bar || baz';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n        assert.instanceOf(token.left, Models.LogicalExpression);\n\n        assert.equal(token.operator.content, '||');\n\n        assert.instanceOf(token.right, Models.Identifier);\n    });\n\n    it('should parse compound logical expressions according to parentheses placement', () => {\n        const code = 'foo && (bar || baz)';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.LogicalExpression);\n        assert.instanceOf(token.left, Models.Identifier);\n\n        assert.equal(token.operator.content, '&&');\n\n        assert.instanceOf(token.right, Models.LogicalExpression);\n    });\n\n    it('should recognise a call expression upon an identifier', () => {\n        const code = 'foo();';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.CallExpression);\n        assert.instanceOf(token.callee, Models.Identifier);\n\n        assert.equal(token.callee.content, 'foo');\n        assert.equal(token.arguments.length, 0);\n    });\n\n    it('should recognise a call expression with an arbitrary number of arguments', () => {\n        const code = 'foo(foo, 2, false);';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.CallExpression);\n        assert.instanceOf(token.callee, Models.Identifier);\n\n        assert.equal(token.callee.content, 'foo');\n        assert.equal(token.arguments.length, 3);\n\n        assert.instanceOf(token.arguments[0], Models.Identifier);\n        assert.instanceOf(token.arguments[1], Models.Literal);\n        assert.instanceOf(token.arguments[2], Models.Literal);\n    });\n\n    it('should recognise a call expression upon a member expression', () => {\n        const code = 'console.log(\"foo\");';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.CallExpression);\n        assert.instanceOf(token.callee, Models.MemberExpression);\n        assert.instanceOf(token.callee.object, Models.Identifier);\n\n        assert.equal(token.callee.object.content, 'console');\n\n        assert.instanceOf(token.callee.property, Models.Identifier);\n\n        assert.equal(token.callee.property.content, 'log');\n        assert.equal(token.arguments.length, 1);\n\n        assert.instanceOf(token.arguments[0], Models.Literal);\n    });\n\n    it('should recognise a variable declaration with keyword `var`', () => {\n        const code = 'var foo = \"bar\";';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.VariableDeclaration);\n\n        assert.equal(token.kind, 'var');\n\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.identifier.content, 'foo');\n\n        assert.instanceOf(token.init, Models.Literal);\n\n        assert.equal(token.init.content, 'bar');\n    });\n\n    it('should recognise a variable declaration with keyword `const`', () => {\n        const code = 'const foo = false;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.VariableDeclaration);\n\n        assert.equal(token.kind, 'const');\n\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.identifier.content, 'foo');\n\n        assert.instanceOf(token.init, Models.Literal);\n\n        assert.equal(token.init.content, 'false');\n    });\n\n    it('should recognise a variable declaration with keyword `let`', () => {\n        const code = 'let foo = 10;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.VariableDeclaration);\n\n        assert.equal(token.kind, 'let');\n\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.identifier.content, 'foo');\n\n        assert.instanceOf(token.init, Models.Literal);\n\n        assert.equal(token.init.content, '10');\n    });\n\n    it('should recognise a return statement with no argument', () => {\n        const code = 'return;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n\n        assert.equal(token.argument, null);\n    });\n\n    it('should recognise a return statement with an identifier as an argument', () => {\n        const code = 'return foo;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n\n        assert.instanceOf(token.argument, Models.Identifier);\n\n        assert.equal(token.argument.content, 'foo');\n    });\n\n    it('should recognise a return statement with a logical expression as an argument', () => {\n        const code = 'return foo && bar;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(token.argument, Models.LogicalExpression);\n    });\n\n    it('should recognise a return statement with a binary expression as an argument', () => {\n        const code = 'return foo > 3;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(token.argument, Models.BinaryExpression);\n    });\n\n    it('should recognise a return statement with a compound logical expression as an argument', () => {\n        const code = 'return this.foo === \"bar\" && this.isFoo && this.isBar;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const logicalExpression = token.argument;\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(logicalExpression, Models.LogicalExpression);\n\n        assert.instanceOf(logicalExpression.left, Models.LogicalExpression);\n        assert.instanceOf(logicalExpression.left.left, Models.BinaryExpression);\n        assert.instanceOf(logicalExpression.left.right, Models.MemberExpression);\n        assert.instanceOf(logicalExpression.right, Models.MemberExpression);\n    });\n\n    it('should recognise a return statement with a unary expression as an argument', () => {\n        const code = 'return !this.isFoo;';\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n\n        assert.instanceOf(token, Models.ReturnStatement);\n        assert.instanceOf(token.argument, Models.UnaryExpression);\n\n        assert.equal(token.argument.operator.content, '!');\n    });\n\n    it('should recognise an abstract block statement', () => {\n        const code = (\n            `{\n                var foo = 'bar';\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const blockBody = program.body[0].body;\n\n        assert.instanceOf(token, Models.BlockStatement);\n        assert.instanceOf(blockBody[0], Models.VariableDeclaration);\n    });\n\n    it('should recognise an abstract block statement with multiple statements', () => {\n        const code = (\n            `{\n                var foo = 'bar';\n\n                return foo || false;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const blockBody = program.body[0].body;\n\n        assert.instanceOf(token, Models.BlockStatement);\n        assert.instanceOf(blockBody[0], Models.VariableDeclaration);\n        assert.instanceOf(blockBody[1], Models.ReturnStatement);\n    });\n\n    it('should recognise a function declaration', () => {\n        const code = (\n            `function foo() {\n                var bar = 'foo';\n\n                return bar;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const functionBody = token.body.body;\n\n        assert.instanceOf(token, Models.FunctionDeclaration);\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.params.length, 0);\n\n        assert.instanceOf(functionBody[0], Models.VariableDeclaration);\n        assert.instanceOf(functionBody[1], Models.ReturnStatement);\n    });\n\n    it('should recognise a function declaration with one or more paramters', () => {\n        const code = (\n            `function foo(x, y) {\n                return x > y;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const functionBody = token.body.body;\n\n        assert.instanceOf(token, Models.FunctionDeclaration);\n        assert.instanceOf(token.identifier, Models.Identifier);\n\n        assert.equal(token.params.length, 2);\n        assert.equal(token.params[0].content, 'x');\n        assert.equal(token.params[1].content, 'y');\n\n        assert.instanceOf(functionBody[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with only a consequent', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a single identifier as a test', () => {\n        const code = (\n            `if (isFoo) {\n                return true;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.Identifier);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a single member expression as a test', () => {\n        const code = (\n            `if (this.isFoo) {\n                return true;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.MemberExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a consequent and alternate', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            } else {\n                return false;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n        const alternate = token.alternate;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate.body[0], Models.ReturnStatement);\n    });\n\n    it('should recognise an if statement with a nested if statement within the alternate', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            } else if (x < y) {\n                return false;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n        const alternate = token.alternate;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate, Models.IfStatement);\n\n        assert.instanceOf(alternate.consequent.body[0], Models.ReturnStatement);\n        assert.equal(alternate.altenative, null);\n    });\n\n    it('should recognise an if statement with a full nested if statement within the alternate', () => {\n        const code = (\n            `if (x > y) {\n                return true;\n            } else if (x < y) {\n                return false;\n            } else {\n                return;\n            }`\n        );\n\n        const program = AstParser.parse(code);\n        const token = program.body[0];\n        const consequent = token.consequent;\n        const alternate = token.alternate;\n\n        assert.instanceOf(token, Models.IfStatement);\n        assert.instanceOf(token.test, Models.BinaryExpression);\n\n        assert.instanceOf(consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate, Models.IfStatement);\n\n        assert.instanceOf(alternate.consequent.body[0], Models.ReturnStatement);\n        assert.instanceOf(alternate.alternate.body[0], Models.ReturnStatement);\n    });\n});"]}