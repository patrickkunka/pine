{"version":3,"sources":["../src/Mappings.js"],"names":["Mappings","getLiteral","match","startIndex","type","literal","Literal","captured","kind","start","end","length","content","replace","raw","getKeyword","keyword","Keyword","KEYWORDS","indexOf","Error","getIdentifier","identifier","Identifier","getWhitespace","whitespace","Whitespace","getPunctuator","punctuator","Punctuator","mapCompoundPunctuator","compoundPunctuator","tokens","segment","slice","token","total","i","tokenString","toString","splice","mapUnaryExpression","unaryExpression","operator","argument","mapMemberExpression","memberExpression","parent","re","RegExp","MEMBER_EXPRESSION","object","segmentString","join","test","property","MemberExpression","mapAssignmentExpression","assignmentExpression","mapBalancedExpression","arguments","mapLogicalExpression","mapBinaryExpression","balancedExpression","hasParentheses","left","right","mapReturnStatement","returnStatement","mapBlockStatement","blockExpression","body","push","mapVariableDeclaration","variableDeclaration","assignmentOffset","assignment","init","mapParametersExpression","parametersExpression","params","mapFunctionDeclaration","functionDeclaration","mapCallExpression","callExpression","loop","callee","mapIfStatement","ifStatement","consequent","alternate"],"mappings":"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","file":"Mappings.js","sourcesContent":["import Patterns from './Patterns';\nimport Models   from './Models';\nimport Entities from './Entities';\n\nclass Mappings {\n    static getLiteral(match, startIndex, type) {\n        const literal   = new Models.Literal();\n        const captured  = match[1];\n\n        literal.kind    = type;\n        literal.start   = startIndex;\n        literal.end     = startIndex + captured.length;\n\n        if (type === 'string') {\n            literal.content = captured.replace(/[\"']/g, '');\n            literal.raw = captured;\n        } else {\n            literal.content = captured;\n        }\n\n        return literal;\n    }\n\n    static getKeyword(match, startIndex) {\n        const keyword   = new Models.Keyword();\n        const captured  = match[1];\n\n        keyword.content = captured;\n        keyword.start   = startIndex;\n        keyword.end     = startIndex + captured.length;\n\n        if (Entities.KEYWORDS.indexOf(captured) < 0) {\n            throw new Error(`[mappings] Illegal token ${captured}`);\n        }\n\n        return keyword;\n    }\n\n    static getIdentifier(match, startIndex) {\n        const identifier    = new Models.Identifier();\n        const captured      = match[1];\n\n        identifier.content  = captured;\n        identifier.start    = startIndex;\n        identifier.end      = startIndex + captured.length;\n\n        return identifier;\n    }\n\n    static getWhitespace(match, startIndex) {\n        const whitespace    = new Models.Whitespace();\n        const captured      = match[1];\n\n        whitespace.content  = captured;\n        whitespace.start    = startIndex;\n        whitespace.end      = startIndex + captured.length;\n\n        return whitespace;\n    }\n\n    static getPunctuator(match, startIndex) {\n        const punctuator    = new Models.Punctuator();\n        const captured      = match[1];\n\n        punctuator.content  = captured;\n        punctuator.start    = startIndex;\n        punctuator.end      = startIndex + captured.length;\n\n        return punctuator;\n    }\n\n    static mapCompoundPunctuator(compoundPunctuator, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let total = -1;\n        let i     = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (token.type !== 'Punctuator' || tokenString === ';') {\n                total = i - 1;\n\n                break;\n            } else {\n                compoundPunctuator.content += token.content;\n            }\n        }\n\n        tokens.splice(startIndex + 1, total);\n\n        tokens[startIndex] = compoundPunctuator;\n    }\n\n    static mapUnaryExpression(unaryExpression, tokens, startIndex) {\n        unaryExpression.operator = tokens[startIndex];\n        unaryExpression.argument = tokens[startIndex + 1];\n\n        tokens.splice(startIndex + 1, 1);\n\n        tokens[startIndex] = unaryExpression;\n    }\n\n    static mapMemberExpression(memberExpression, tokens, startIndex, parent=null) {\n        const segment = tokens.slice(startIndex);\n\n        let i = -1;\n\n        for (i = 0; i <= 2; i++) {\n            let token = segment[i];\n            let tokenString = token.toString();\n            let re = new RegExp('^' + Patterns.MEMBER_EXPRESSION);\n\n            if (tokenString === '.') continue;\n\n            if (parent) {\n                memberExpression.parent = parent;\n            }\n\n            if (i === 0) {\n                if (tokenString !== 'identifier' && parent) {\n                    throw new Error(`[mapper#mapMemberExpression] Illegal token ${tokenString}`);\n                }\n\n                memberExpression.object = token;\n            } else {\n                let segmentString = tokens.slice(startIndex + i).join(' ');\n\n                if (re.test(segmentString)) {\n                    memberExpression.property = new Models.MemberExpression();\n\n                    Mappings.mapMemberExpression(memberExpression.property, tokens, startIndex + i, memberExpression);\n                } else {\n                    memberExpression.property = token;\n                }\n            }\n        }\n\n        tokens.splice(startIndex + 1, 2);\n\n        tokens[startIndex] = memberExpression;\n    }\n\n    static mapAssignmentExpression(assignmentExpression, tokens, startIndex) {\n        Mappings.mapBalancedExpression(...arguments);\n\n        tokens.splice(startIndex + 1, 1);\n    }\n\n    static mapLogicalExpression() {\n        Mappings.mapBalancedExpression(...arguments);\n    }\n\n    static mapBinaryExpression() {\n        Mappings.mapBalancedExpression(...arguments);\n    }\n\n    static mapBalancedExpression(balancedExpression, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let hasParentheses = false;\n        let token = null;\n        let i = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if ((i === 0 && tokenString === '(') || (hasParentheses && tokenString === ')')) {\n                hasParentheses = true;\n\n                continue;\n            } else if (['comparison_operator', 'logical_operator', '='].indexOf(tokenString) > -1) {\n                if (balancedExpression.operator !== null) {\n                    if (hasParentheses) {\n                        startIndex++;\n                        i--;\n                    }\n\n                    break;\n                }\n\n                balancedExpression.operator = token;\n            } else if (balancedExpression.left === null) {\n                balancedExpression.left = token;\n            } else if (balancedExpression.right === null) {\n                balancedExpression.right = token;\n            } else {\n                break;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i - 1);\n\n        tokens[startIndex] = balancedExpression;\n    }\n\n    static mapReturnStatement(returnStatement, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (tokenString === 'return') {\n                continue;\n            } else if (tokenString === ';') {\n                break;\n            } else {\n                returnStatement.argument = token;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i);\n\n        tokens[startIndex] = returnStatement;\n    }\n\n    static mapBlockStatement(blockExpression, tokens, startIndex) {\n        let i = startIndex + 1;\n        let token = null;\n\n        while ((token = tokens[i]) && token.toString() !== '}') {\n            blockExpression.body.push(token);\n\n            i++;\n        }\n\n        tokens.splice(startIndex + 1, blockExpression.body.length + 1);\n\n        tokens[startIndex] = blockExpression;\n    }\n\n    static mapVariableDeclaration(variableDeclaration, tokens, startIndex) {\n        const assignmentOffset = 1;\n        const assignment = tokens[assignmentOffset];\n\n        variableDeclaration.kind        = tokens[startIndex].content;\n        variableDeclaration.identifier  = assignment.left;\n        variableDeclaration.init        = assignment.right;\n\n        tokens.splice(startIndex + 1, 1);\n\n        tokens[startIndex] = variableDeclaration;\n    }\n\n    static mapParametersExpression(parametersExpression, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['(', ','].indexOf(tokenString) > -1) {\n                continue;\n            } else if (tokenString === ')') {\n                break;\n            } else {\n                parametersExpression.params.push(token);\n            }\n        }\n\n        if (parametersExpression.params.length > 1) {\n            tokens.splice(startIndex + 1, i);\n        } else {\n            tokens.splice(startIndex + 1, 2);\n        }\n\n        tokens[startIndex] = parametersExpression;\n    }\n\n    static mapFunctionDeclaration(functionDeclaration, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i     = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['function', '(', ')', 'get', 'set'].indexOf(tokenString) > -1) continue;\n\n            switch (tokenString) {\n                case 'identifier':\n                    functionDeclaration.identifier = token;\n\n                    break;\n                case 'parameters_expression':\n                    functionDeclaration.params = token.params;\n\n                    break;\n                case 'block_statement':\n                    functionDeclaration.body = token;\n\n                    break;\n                default:\n                    throw new Error('[mapping#mapFunctionDeclaration()] Unexpected token');\n            }\n        }\n\n        tokens.splice(startIndex + 1, i);\n\n        tokens[startIndex] = functionDeclaration;\n    }\n\n    static mapCallExpression(callExpression, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i     = -1;\n\n        loop:\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['(', ')', ';'].indexOf(tokenString) > -1) continue;\n\n            switch (tokenString) {\n                case 'identifier':\n                case 'member_expression':\n                    callExpression.callee = token;\n\n                    break;\n                case 'parameters_expression':\n                    callExpression.arguments = token.params;\n\n                    break;\n                default:\n                    break loop;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i - 1);\n\n        tokens[startIndex] = callExpression;\n    }\n\n    static mapIfStatement(ifStatement, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i     = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['if', 'else', '(', ')'].indexOf(tokenString) > -1) continue;\n\n            if (['logical_expression', 'binary_expression', 'parameters_expression'].indexOf(tokenString) > -1) {\n                ifStatement.test = tokenString === 'parameters_expression' ? token.params[0] : token;\n            } else if (['block_statement', 'if_statement'].indexOf(tokenString) > -1) {\n                if (ifStatement.consequent) {\n                    ifStatement.alternate = token;\n                } else {\n                    ifStatement.consequent = token;\n                }\n            } else {\n                break;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i - 1);\n\n        tokens[startIndex] = ifStatement;\n    }\n}\n\nexport default Mappings;"]}