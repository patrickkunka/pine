{"version":3,"sources":["../src/AstParser.js"],"names":["AstParser","parse","programString","classInstance","Program","tokens","ingestProgramString","parseTokensIntoAst","body","startIndex","token","matchToken","Whitespace","push","end","length","slice","match","RegExp","BOOLEAN","exec","getLiteral","NUMBER","KEYWORD","getKeyword","PUNCTUATOR","getPunctuator","STRING","IDENTIFIER","getIdentifier","WHITESPACE","getWhitespace","Error","i","type","Model","pascalCase","mapper","pattern","traverseTokens","testTokensAgainstPattern","tokensString","join","re","getStartIndexFromMatch","structure","class","toString","matchIndex","index","stringBefore","split","Models","Patterns"],"mappings":"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","file":"AstParser.js","sourcesContent":["import Util     from './Util';\n\nimport Models   from './Models';\nimport Mappings from './Mappings';\nimport Patterns from './Patterns';\nimport flow     from './flow.json';\n\nclass AstParser {\n    /**\n     * @param   {string} programString\n     * @param   {object} [classInstance=null]\n     * @return  {Program}\n     */\n\n    static parse(programString, classInstance=null) {\n        const Program = new Models.Program();\n        const tokens = AstParser.ingestProgramString(programString);\n\n        AstParser.parseTokensIntoAst(tokens, classInstance);\n\n        Program.body = tokens;\n\n        return Program;\n    }\n\n    /**\n     * @param   {string} programString\n     * @return  {Array.<Token>}\n     */\n\n    static ingestProgramString(programString) {\n        const tokens = [];\n\n        let startIndex = 0;\n        let token = null;\n\n        while ((token = AstParser.matchToken(programString, startIndex))) {\n            if (!(token instanceof Models.Whitespace)) {\n                tokens.push(token);\n            }\n\n            startIndex = token.end;\n\n            if (startIndex > programString.length - 1) {\n                // End of string\n\n                break;\n            }\n        }\n\n        return tokens;\n    }\n\n    /**\n     * @param   {string} programString\n     * @param   {number} startIndex\n     * @return  {Token|null}\n     */\n\n    static matchToken(programString, startIndex) {\n        const slice = programString.slice(startIndex);\n\n        let match = null;\n\n        if ((match = new RegExp(Patterns.BOOLEAN).exec(slice))) {\n            return Mappings.getLiteral(match, startIndex, 'boolean');\n        } if ((match = new RegExp(Patterns.NUMBER).exec(slice))) {\n            return Mappings.getLiteral(match, startIndex, 'number');\n        } else if ((match = new RegExp(Patterns.KEYWORD).exec(slice))) {\n            return Mappings.getKeyword(match, startIndex);\n        } else if ((match = new RegExp(Patterns.PUNCTUATOR).exec(slice))) {\n            return Mappings.getPunctuator(match, startIndex);\n        } else if ((match = new RegExp(Patterns.STRING).exec(slice))) {\n            return Mappings.getLiteral(match, startIndex, 'string');\n        } else if ((match = new RegExp(Patterns.IDENTIFIER).exec(slice))) {\n            return Mappings.getIdentifier(match, startIndex);\n        } else if ((match = new RegExp(Patterns.WHITESPACE).exec(slice))) {\n            return Mappings.getWhitespace(match, startIndex);\n        }\n\n        throw new Error('[ast-parser] Unknown token');\n    }\n\n    /**\n     * @param   {Array.<Token>}   tokens\n     * @param   {Models.Class}    classInstance\n     * @return  {void}\n     */\n\n    static parseTokensIntoAst(tokens, classInstance) {\n        for (let i = 0, type; i < flow.length; i++) {\n            type = flow[i];\n\n            let Model = Models[Util.pascalCase(type)];\n            let mapper = Mappings['map' + Util.pascalCase(type)];\n            let pattern = Patterns[type];\n\n            AstParser.traverseTokens(tokens, Model, mapper, pattern, classInstance);\n        }\n    }\n\n    /**\n     * @static\n     * @param   {Array.<Token>}   tokens\n     * @param   {string}          pattern\n     * @return  {number}\n     */\n\n    static testTokensAgainstPattern(tokens, pattern) {\n        const tokensString = tokens.join(' ');\n        const re = new RegExp(pattern, 'g');\n        const match = re.exec(tokensString);\n\n        const startIndex = match ? AstParser.getStartIndexFromMatch(match, tokensString) : -1;\n\n        return startIndex;\n    }\n\n    /**\n     * @static\n     * @param {Array.<Token>}       tokens\n     * @param {function}            Model\n     * @param {function}            Mapper\n     * @param {string}              pattern\n     * @param {Models.Class|null}   classInstance\n     */\n\n    static traverseTokens(tokens, Model, mapper, pattern, classInstance) {\n        let startIndex = -1;\n\n        while ((startIndex = AstParser.testTokensAgainstPattern(tokens, pattern)) > -1) {\n            let structure = new Model();\n\n            structure.class = classInstance;\n\n            mapper(structure, tokens, startIndex);\n\n            if (structure.toString() === 'block_statement') {\n                AstParser.parseTokensIntoAst(structure.body, classInstance);\n            }\n        }\n    }\n\n    /**\n     * @static\n     * @param   {object} match\n     * @param   {string} tokensString\n     * @return  {number}\n     */\n\n    static getStartIndexFromMatch(match, tokensString) {\n        const matchIndex = match.index;\n        const stringBefore = tokensString.slice(0, matchIndex);\n        const startIndex = stringBefore.split(' ').length;\n\n        return startIndex - 1;\n    }\n}\n\nAstParser.Models = Models;\nAstParser.Patterns = Patterns;\n\nexport default AstParser;"]}