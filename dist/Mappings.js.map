{"version":3,"sources":["../src/Mappings.js"],"names":["patterns","models","Mappings","getLiteral","match","startIndex","type","literal","Literal","captured","kind","start","end","length","content","replace","raw","getKeyword","keyword","Keyword","indexOf","Error","getIdentifier","identifier","Identifier","getWhitespace","whitespace","Whitespace","getPunctuator","punctuator","Punctuator","mapCompoundPunctuator","compoundPunctuator","tokens","segment","slice","token","total","i","tokenString","toString","splice","mapUnaryExpression","unaryExpression","operator","argument","mapMemberExpression","memberExpression","parent","re","RegExp","MEMBER_EXPRESSION","object","segmentString","join","test","property","MemberExpression","mapAssignmentExpression","assignmentExpression","mapBalancedExpression","arguments","mapLogicalExpression","mapBinaryExpression","balancedExpression","hasParentheses","left","right","mapReturnStatement","returnStatement","mapBlockStatement","blockExpression","body","push","mapVariableDeclaration","variableDeclaration","assignmentOffset","assignment","init","mapParametersExpression","parametersExpression","params","mapFunctionDeclaration","functionDeclaration","mapCallExpression","callExpression","loop","callee","mapIfStatement","ifStatement","consequent","alternate"],"mappings":"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","file":"Mappings.js","sourcesContent":["import * as patterns from './patterns';\nimport * as models   from './models';\n\nimport {\n    KEYWORDS\n} from './Entities';\n\nclass Mappings {\n    static getLiteral(match, startIndex, type) {\n        const literal   = new models.Literal();\n        const captured  = match[1];\n\n        literal.kind    = type;\n        literal.start   = startIndex;\n        literal.end     = startIndex + captured.length;\n\n        if (type === 'string') {\n            literal.content = captured.replace(/[\"']/g, '');\n            literal.raw = captured;\n        } else {\n            literal.content = captured;\n        }\n\n        return literal;\n    }\n\n    static getKeyword(match, startIndex) {\n        const keyword   = new models.Keyword();\n        const captured  = match[1];\n\n        keyword.content = captured;\n        keyword.start   = startIndex;\n        keyword.end     = startIndex + captured.length;\n\n        if (KEYWORDS.indexOf(captured) < 0) {\n            throw new Error(`[mappings] Illegal token ${captured}`);\n        }\n\n        return keyword;\n    }\n\n    static getIdentifier(match, startIndex) {\n        const identifier    = new models.Identifier();\n        const captured      = match[1];\n\n        identifier.content  = captured;\n        identifier.start    = startIndex;\n        identifier.end      = startIndex + captured.length;\n\n        return identifier;\n    }\n\n    static getWhitespace(match, startIndex) {\n        const whitespace    = new models.Whitespace();\n        const captured      = match[1];\n\n        whitespace.content  = captured;\n        whitespace.start    = startIndex;\n        whitespace.end      = startIndex + captured.length;\n\n        return whitespace;\n    }\n\n    static getPunctuator(match, startIndex) {\n        const punctuator    = new models.Punctuator();\n        const captured      = match[1];\n\n        punctuator.content  = captured;\n        punctuator.start    = startIndex;\n        punctuator.end      = startIndex + captured.length;\n\n        return punctuator;\n    }\n\n    static mapCompoundPunctuator(compoundPunctuator, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let total = -1;\n        let i     = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (token.type !== 'Punctuator' || tokenString === ';') {\n                total = i - 1;\n\n                break;\n            } else {\n                compoundPunctuator.content += token.content;\n            }\n        }\n\n        tokens.splice(startIndex + 1, total);\n\n        tokens[startIndex] = compoundPunctuator;\n    }\n\n    static mapUnaryExpression(unaryExpression, tokens, startIndex) {\n        unaryExpression.operator = tokens[startIndex];\n        unaryExpression.argument = tokens[startIndex + 1];\n\n        tokens.splice(startIndex + 1, 1);\n\n        tokens[startIndex] = unaryExpression;\n    }\n\n    static mapMemberExpression(memberExpression, tokens, startIndex, parent=null) {\n        const segment = tokens.slice(startIndex);\n\n        let i = -1;\n\n        for (i = 0; i <= 2; i++) {\n            let token = segment[i];\n            let tokenString = token.toString();\n            let re = new RegExp('^' + patterns.MEMBER_EXPRESSION);\n\n            if (tokenString === '.') continue;\n\n            if (parent) {\n                memberExpression.parent = parent;\n            }\n\n            if (i === 0) {\n                if (tokenString !== 'identifier' && parent) {\n                    throw new Error(`[mapper#mapMemberExpression] Illegal token ${tokenString}`);\n                }\n\n                memberExpression.object = token;\n            } else {\n                let segmentString = tokens.slice(startIndex + i).join(' ');\n\n                if (re.test(segmentString)) {\n                    memberExpression.property = new models.MemberExpression();\n\n                    Mappings.mapMemberExpression(memberExpression.property, tokens, startIndex + i, memberExpression);\n                } else {\n                    memberExpression.property = token;\n                }\n            }\n        }\n\n        tokens.splice(startIndex + 1, 2);\n\n        tokens[startIndex] = memberExpression;\n    }\n\n    static mapAssignmentExpression(assignmentExpression, tokens, startIndex) {\n        Mappings.mapBalancedExpression(...arguments);\n\n        tokens.splice(startIndex + 1, 1);\n    }\n\n    static mapLogicalExpression() {\n        Mappings.mapBalancedExpression(...arguments);\n    }\n\n    static mapBinaryExpression() {\n        Mappings.mapBalancedExpression(...arguments);\n    }\n\n    static mapBalancedExpression(balancedExpression, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let hasParentheses = false;\n        let token = null;\n        let i = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if ((i === 0 && tokenString === '(') || (hasParentheses && tokenString === ')')) {\n                hasParentheses = true;\n\n                continue;\n            } else if (['comparison_operator', 'logical_operator', '='].indexOf(tokenString) > -1) {\n                if (balancedExpression.operator !== null) {\n                    if (hasParentheses) {\n                        startIndex++;\n                        i--;\n                    }\n\n                    break;\n                }\n\n                balancedExpression.operator = token;\n            } else if (balancedExpression.left === null) {\n                balancedExpression.left = token;\n            } else if (balancedExpression.right === null) {\n                balancedExpression.right = token;\n            } else {\n                break;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i - 1);\n\n        tokens[startIndex] = balancedExpression;\n    }\n\n    static mapReturnStatement(returnStatement, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (tokenString === 'return') {\n                continue;\n            } else if (tokenString === ';') {\n                break;\n            } else {\n                returnStatement.argument = token;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i);\n\n        tokens[startIndex] = returnStatement;\n    }\n\n    static mapBlockStatement(blockExpression, tokens, startIndex) {\n        let i = startIndex + 1;\n        let token = null;\n\n        while ((token = tokens[i]) && token.toString() !== '}') {\n            blockExpression.body.push(token);\n\n            i++;\n        }\n\n        tokens.splice(startIndex + 1, blockExpression.body.length + 1);\n\n        tokens[startIndex] = blockExpression;\n    }\n\n    static mapVariableDeclaration(variableDeclaration, tokens, startIndex) {\n        const assignmentOffset = 1;\n        const assignment = tokens[assignmentOffset];\n\n        variableDeclaration.kind        = tokens[startIndex].content;\n        variableDeclaration.identifier  = assignment.left;\n        variableDeclaration.init        = assignment.right;\n\n        tokens.splice(startIndex + 1, 1);\n\n        tokens[startIndex] = variableDeclaration;\n    }\n\n    static mapParametersExpression(parametersExpression, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['(', ','].indexOf(tokenString) > -1) {\n                continue;\n            } else if (tokenString === ')') {\n                break;\n            } else {\n                parametersExpression.params.push(token);\n            }\n        }\n\n        if (parametersExpression.params.length > 1) {\n            tokens.splice(startIndex + 1, i);\n        } else {\n            tokens.splice(startIndex + 1, 2);\n        }\n\n        tokens[startIndex] = parametersExpression;\n    }\n\n    static mapFunctionDeclaration(functionDeclaration, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i     = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['function', '(', ')', 'get', 'set'].indexOf(tokenString) > -1) continue;\n\n            switch (tokenString) {\n                case 'identifier':\n                    functionDeclaration.identifier = token;\n\n                    break;\n                case 'parameters_expression':\n                    functionDeclaration.params = token.params;\n\n                    break;\n                case 'block_statement':\n                    functionDeclaration.body = token;\n\n                    break;\n                default:\n                    throw new Error('[mapping#mapFunctionDeclaration()] Unexpected token');\n            }\n        }\n\n        tokens.splice(startIndex + 1, i);\n\n        tokens[startIndex] = functionDeclaration;\n    }\n\n    static mapCallExpression(callExpression, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i     = -1;\n\n        loop:\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['(', ')', ';'].indexOf(tokenString) > -1) continue;\n\n            switch (tokenString) {\n                case 'identifier':\n                case 'member_expression':\n                    callExpression.callee = token;\n\n                    break;\n                case 'parameters_expression':\n                    callExpression.arguments = token.params;\n\n                    break;\n                default:\n                    break loop;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i - 1);\n\n        tokens[startIndex] = callExpression;\n    }\n\n    static mapIfStatement(ifStatement, tokens, startIndex) {\n        const segment = tokens.slice(startIndex);\n\n        let token = null;\n        let i     = -1;\n\n        for (i = 0; (token = segment[i]); i++) {\n            let tokenString = token.toString();\n\n            if (['if', 'else', '(', ')'].indexOf(tokenString) > -1) continue;\n\n            if (['logical_expression', 'binary_expression', 'parameters_expression'].indexOf(tokenString) > -1) {\n                ifStatement.test = tokenString === 'parameters_expression' ? token.params[0] : token;\n            } else if (['block_statement', 'if_statement'].indexOf(tokenString) > -1) {\n                if (ifStatement.consequent) {\n                    ifStatement.alternate = token;\n                } else {\n                    ifStatement.consequent = token;\n                }\n            } else {\n                break;\n            }\n        }\n\n        tokens.splice(startIndex + 1, i - 1);\n\n        tokens[startIndex] = ifStatement;\n    }\n}\n\nexport default Mappings;"]}